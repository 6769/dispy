<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"> 
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"> 
  <head> 
    <meta http-equiv="content-type" content="text/html; charset=utf-8" /> 
    <meta name="description" content="Python module for distributing computations across multiple processors on a single machine, among many machines in a cluster, grid or cloud. The computations can be standalone programs or python functions." /> 
    <meta name="keywords" content="dispy, python, parallel processing, distributed computing, cluster computing" /> 
    <title> 
      SourceForge.net: dispy - Project Web Hosting - Open Source Software
    </title> 

<link rel="stylesheet" type="text/css" href="style.css" />
 
  </head> 
  <body> 
    <small><a href="http://sourceforge.net/projects/dispy/">dispy</a>:  Project Web Hosting - Open Source Software</small> 
    <h1>dispy</h1> 
    <div id="content-mask">
      <div id="content-container"> 
	<div id="content-menu">
	  <ul>
            <li><a href="index.html">Project Page</a></li> 
            <li><a href="dispy.html">dispy</a></li> 
            <li><a href="dispynode.html">dispynode</a></li> 
            <li><a href="dispyscheduler.html">dispyscheduler</a></li> 
            <li><a href="dispynetrelay.html">dispynetrelay</a></li>
	  </ul>
	  <hr />
	  <ul>
            <li><a href="http://sourceforge.net/projects/dispy/files">Download dispy</a></li> 
            <li><a href="http://sourceforge.net/projects/dispy/">Project details</a></li> 
            <li><a href="http://sourceforge.net/projects/dispy/support">Get support</a></li>
	  </ul>
	</div> 

	<div id="content-wrap"> 
	  <div id="content"> 

<center><h2>asyncoro</h2></center>
<p>
  asyncoro, part of
  <a href="http://sourceforge.net/projects/dispy/files">dispy</a>
  package, is a framework for developing (concurrent) programs with
  asynchronous sockets and coroutines. The coroutines should use
  'yield' with tasks that take time to complete, such as waiting for
  I/O completion, or sleep. Each yield statement gives control to
  asyncoro's scheduler, which interleaves executions of coroutines,
  similar to the way an operating system executes multiple
  processes. asyncoro includes polling mechanisms epoll, kqueue and
  poll, and Windows I/O Completion Ports (IOCP) for high performance
  and scalability.  asyncoro can be used independently of dispy.</p>

<h4>Details</h4>
<p>

AsynCoro and associated classes in asyncoro.py file provide framework
for developing programs with coroutines and asynchronous I/O for
sockets. Unlike with the case of callbacks used in event-based
frameworks, the programs developed with asyncoro will have same logic
as python progorams with synchronous sockets and threads, except for
converting sockets to asynchronous model with AsynCoroSocket class,
'yield' when waiting for completion of tasks (i.e., socket operations,
sleep and waiting on CoroCondition) and using CoroLock, CoroCondition
in place of thread locking. Tehcnically, CoroLock is not needed (as
there is no forced preemption with coroutines and at most one
coroutine is executing at anytime), but if one wants to maintain same
program for both synchronous and asynchronous models, it would be
simple to interchange threading.Lock and CoroLock, threading.Condition
and CoroCondition, and a few syntactic changes.
</p>

<p>
For example, a simple tcp server with asyncoro looks like:
</p>
<code>def process(sock, coro=None):
    sock = AsynCoroSocket(sock)
    # get (exactly) 4MB of data, for example, and let other coroutines
    # (process methods, in this case) execute in the meantime
    data = yield sock.recvall(4096*1024)
    ...
    yield sock.sendall(reply)
    sock.close()

if __name__ == '__main__':
    host, port = '', 3456
    # start asyncoro scheduler before creating coroutines
    asyncoro = AsynCoro()
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sock.bind((host, port))
    sock.listen(128)
    while True:
        conn, addr = sock.accept()
        Coro(process, conn)
</code>

<p>
Here we mixed synchronous sockets in server loop and asynchronous
sockets in the 'process' method for illustration. The server does not
do any processing, so the loop can quickly accept connections. Each
request is processed in a separate coroutine. A coroutine method must
have 'coro=None' default argument. The coroutine builder Coro will set
coro argument with the Coro instance, which is used for calling
methods in Coro class. In the 'process' method, socket I/O operations
are called with 'yield'. With these statements, the I/O operation is
initiated and control goes to AsynCoro's scheduler. When the I/O
operation is complete, the scheduler returns the results of the method
back to the method. During the time it takes to complete the I/O
operation, the scheduler executes other coroutines.
</p>

<p>When it is necessary to suspend/sleep, a coro (instance of Coro)
should use coro.sleep(timeout=None) instead of time.sleep. A
coro.sleep used with 'yield' allows other coros to execute during
sleep, whereas time.sleep blocks other coros. If timeout is None, some
other coro or program thread must wake it up. If timetout is a number,
the coro sleeps for that many seconds (or fractions of second) unless
someone else wakes it up before. A sleeping coro can be woken
up/resumed with coro.resume(update=None). The update value is 'sent'
to the sleeping coro, so that 'yield' that caused it to suspend will
receive update. Thus, if a method suspends (itself) with <tt>news =
yield coro1.sleep()</tt> and later, another coro, coro2, can wake it
up with <tt>coro1.wakeup('rained')</tt>. This sets 'news' to 'rained'
in coro1 and coro1 resumes execution.  The update can be any python
object. asyncoro framework requires that 'resume' called on only
currently sleeping coro(s). Otherwise, the update is ignored (and a
warning is given). If necessary, cooperating coros can use a
CoroCondition to signal when a coro is going to sleep. Note that
'sleep' must be used with 'yield'; otherwise, entire coroutine suite
will be locked up.
  </p>

<p>
With python's coroutines, a coroutine stops at each yield statement
and proceeds only after next iteration is asked for (with 'next' or
'send' methods). With asyncoro, yield is used to convey to the
scheduler that the statement associated with yield is time consuming
so the scheduler can run other coroutines while waiting for that task
to complete. When the task completes, the scheduler will execute the
coroutine. Thus, asyncoro coroutines continue execution (interleaved
with other coroutines) after each yield, unless it has been suspended
with sleep/suspend method. With asyncoro, the coroutines must not
'send' values or call 'next' for the coroutines created with 'Coro'
class. They can call 'next' for generators (methods not associated
with 'Coro' instance). However, those generators must not use any
time-consuming tasks. If coroutines need to exchange data (as is done
with python's yield), they can use asyncoro's suspend and resume
methods: A coroutine to recieve data should suspend itself and a
coroutine to send data should wake up the suspended coroutine, as
explained above.
</p>

<p>
With asyncoro's 'sleep'/'suspend' and 'wakeup'/'resume' methods,
coroutines can send/receive values to/from each other at deliberate
locations, and with 'yield' statements cooperate scheduling their
execution (play relay race).
</p>

<p>
See dispy files for details/examples on how to use asyncoro.
</p>
<p>
Following is asyncoro version
of <a href="http://nichol.as/asynchronous-servers-in-python">Ping Pong
Benchmark</a> server:
<code>import socket
from asyncoro import AsynCoroSocket, Coro, AsynCoro

def process(conn, coro=None):
    conn = AsynCoroSocket(conn)
    yield conn.sendall("HTTP/1.0 200 OK\r\nContent-Length: 5\r\n\r\nPong!\r\n")
    conn.close()

if __name__ == '__main__':
    scheduler = AsynCoro()

    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    sock.bind(('', 8010))
    sock.listen(5000)

    while True:
        try:
            conn, addr = sock.accept()
        except KeyboardInterrupt:
            break
        Coro(process, conn)
    scheduler.terminate()
</code>
  </p>

	  </div>
	</div> 
      </div> 
    </div> 
    <div id="footer"> 
      <p> 
        <a href="http://sourceforge.net/"> 
          Project Web Hosted by <img src="http://sflogo.sourceforge.net/sflogo.php?group_id=539226&amp;type=3" alt="SourceForge.net" /> 
        </a> 
      </p> 
      <p> 
        &copy;Copyright 1999-2009 -
        <a href="http://geek.net" title="Network which provides and promotes Open Source software downloads, development, discussion and news."> 
          Geeknet</a>, Inc., All Rights Reserved
      </p> 
      <p> 
        <a href="http://sourceforge.net/about"> 
          About
        </a> 
        -
        <a href="http://sourceforge.net/tos/tos.php"> 
          Legal
        </a> 
        -
        <a href="http://p.sf.net/sourceforge/getsupport"> 
          Help
        </a> 
      </p> 
    </div> 
  </body> 
</html> 
