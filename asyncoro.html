<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"> 
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"> 
  <head> 
    <meta http-equiv="content-type" content="text/html; charset=utf-8" /> 
    <meta name="description" content="Python module for distributing computations across multiple processors on a single machine, among many machines in a cluster, grid or cloud. The computations can be standalone programs or python functions." /> 
    <meta name="keywords" content="dispy, python, parallel processing, distributed computing, cluster computing" /> 
    <title> 
      SourceForge.net: dispy - Project Web Hosting - Open Source Software
    </title> 

<link rel="stylesheet" type="text/css" href="style.css" />
 
  </head> 
  <body> 
    <small><a href="http://sourceforge.net/projects/dispy/">dispy</a>:  Project Web Hosting - Open Source Software</small> 
    <h1>dispy</h1> 
    <div id="content-mask">
      <div id="content-container"> 
	<div id="content-menu">
	  <ul>
            <li><a href="index.html">Project Page</a></li> 
            <li><a href="dispy.html">dispy</a></li> 
            <li><a href="dispynode.html">dispynode</a></li> 
            <li><a href="dispyscheduler.html">dispyscheduler</a></li> 
            <li><a href="dispynetrelay.html">dispynetrelay</a></li>
	  </ul>
	  <hr />
	  <ul>
            <li><a href="http://sourceforge.net/projects/dispy/files">Download dispy</a></li> 
            <li><a href="http://sourceforge.net/projects/dispy/">Project details</a></li> 
            <li><a href="http://sourceforge.net/projects/dispy/support">Get support</a></li>
	  </ul>
	</div> 

	<div id="content-wrap"> 
	  <div id="content"> 

<center><h2>asyncoro</h2></center>
<p>
  asyncoro, part of
  <a href="http://sourceforge.net/projects/dispy/files">dispy</a>
  package, is a framework for developing concurrent programs with
  asynchronous event completion and coroutines. Asynchronous
  completions currently implemented in asyncoro are socket I/O
  operations, database cursors, sleep timers, (conditional) event
  notification and semaphores.  The coroutines should use 'yield' with
  these completions. Each yield statement gives control to asyncoro's
  scheduler, which interleaves executions of coroutines, similar to
  the way an operating system executes multiple processes. Programs
  developed with asyncoro will have same logic as python progorams
  with synchronous sockets and threads, except for a few syntactic
  changes. asyncoro supports polling mechanisms epoll, kqueue,
  /dev/poll, and poll, and Windows I/O Completion Ports (IOCP) for
  high performance and scalability, and SSL for security.  asyncoro
  can be used independently of dispy.</p>

<h4>Details</h4>
<p>

Traditional methods of threads and synchronous sockets have many
drawbacks, especially with Python due to global interpreter lock (GIL)
that forces only one active thread of execution. This approach is not
suited for large number of concurrent connections, known
as <a href="http://www.kegel.com/c10k.html">C10K problem</a>. In
addition, threads in Python have both memory and time overheads,
especially on multi-core systems
(see <a href="http://www.dabeaz.com/python/GIL.pdf">Inside the Python
GIL</a>).</p>

<p>
  Many <a href="http://nichol.as/asynchronous-servers-in-python">asynchronous
  frameworks</a> are now available to deal with this problem. Unlike
  these frameworks, asyncoro framework is very similar to thread based
  programming so that there is almost no learning curve - existing
  thread implementations can be converted to asyncoro almost
  mechanically (although it cannot be automated). In fact, it may be
  easier to use asyncoro than threads, as locking is not required with
  asyncoro (see below).
</p>

<p>
For example, a simple tcp server with asyncoro looks like:
</p>
<code>def process(sock, coro=None):
    sock = AsynCoroSocket(sock)
    # get (exactly) 4MB of data, for example, and let other coroutines
    # (process methods, in this case) execute in the meantime
    data = yield sock.recvall(4096*1024)
    ...
    yield sock.sendall(reply)
    sock.close()

if __name__ == '__main__':
    host, port = '', 3456
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sock.bind((host, port))
    sock.listen(128)
    while True:
        conn, addr = sock.accept()
        Coro(process, conn)
</code>

<p>
Here we mixed synchronous sockets in server loop and asynchronous
sockets in the 'process' method for illustration. The server does not
do any processing, so the loop can quickly accept connections. Each
request is processed in a separate coroutine. Note that IO event loop
is transparent - asyncoro handles IO events by itself. A coroutine
should have 'coro=None' default argument. The coroutine builder Coro
(which is similar to threading.Thread) will set coro argument with the
Coro instance, which is used for calling methods in Coro class (see
below). In the 'process' method, socket I/O operations are called with
'yield'. With these statements, the I/O operation is initiated and
control goes to AsynCoro's scheduler for scheduling other coroutines
as well as processing I/O events. When the I/O operation is complete,
the scheduler returns the results of the I/O operation back to the
method. During the time it takes to complete an I/O operation, the
scheduler executes other coroutines (in this case, other 'process'
coroutines).
</p>

<h4>API</h4>
<p>
  asyncoro framework consists of AsynCoro scheduler, Coro factory to
  create coroutines from generator functions, AsynCoroSocket to
  convert regular synchronous sockets to asynchronous sockets,
  AsynCoroDBCursor to convert database cursor
  operations <tt>execute</tt> and <tt>executemany</tt> to asynchronous
  operations, and locking, event, semaphore primitives similar to
  thread primitives.  asyncoro has been tested with Python versions
  2.7 and 3.2 under Linux, OS X and Windows. Under Windows asyncoro
  uses IOCP only
  if <a href="https://sourceforge.net/projects/pywin32/files/pywin32/">Python
  for Windows Extensions</a> (pywin32) is installed. pywin32 works
  with Windows 32-bit and 64-bit.
  </p>

<ul>
  <li>
    <b>AsynCoro</b> is a (singleton) scheduler that runs coroutines similar to
    operating system's scheduler that runs multiple processes. It is
    initialized when asyncoro module is imported. If necessary, the
    scheduler instance can be obtained with <tt>AsynCoro()</tt>
    or <tt>AsynCoro.instance()</tt>. The scheduler runs in a separate
    thread. It has two methods:
    <ul>
      <li>
	<b>join()</b> method waits for all scheduled coroutines to
	finish. Since scheduler runs in a separate thread, user
	program must wait until all coroutines are finished or the
	program reached some other end point etc. Note that if any
	scheduled coroutine does not finish (for example, a server),
	<tt>join()</tt> will hang.  If necessary, after join returns,
	more coroutines may be added to the scheduler.
      </li>
      <li>
	<b>terminate()</b> method terminates all scheduled
	coroutines and then the scheduler itself. If necessary, a new
	scheduler instance may be created with <tt>AsynCoro()</tt>
	or <tt>AsynCoro.instance()</tt>
      </li>
    </ul>
    </li>
  <li>Threads in synchronous programms can be replaced with coroutines
    using asyncoro's <b>Coro</b> class (i.e., Coro replaces
    threading.Thread). <tt>Coro(target[, arg1, arg2, ...])</tt>
    creates a coroutine. "target" must be a generator function (a
    function with 'yield' statements). "arg1", "arg2" are arguments or
    keyword arguments to "target". "target" generator function must have
    "coro=None" keyword argument. Coro instantiaion replaces None with
    the instance of coro, so coroutine can use this to invoke methods
    in Coro class (see below). Consider the function

    <code>def get_reply(sock, msg, coro=None):
    yield sock.send(msg)
    reply = yield sock.recv(1024)
    yield reply</code>
    It can be made a coroutine with
    <tt>Coro(get_reply, conn, "ping")</tt> so that generator function is called
    with <tt>sock=conn, msg="ping"</tt>. 'coro' keyword argument
    is automatically supplied by Coro; it should not be in the
    arguments to Coro. When a coroutine is created with Coro, it is
    added to AsynCoro scheduler and starts executing - there is no
    need to start it explicitly, as done with threads. Note that
    generator functions cannot use 'return' statement; instead,
    AsynCoro treats the last value yielded in the coroutine as the
    return value of the function (in this case, 'reply' is equivalent
    to return value of get_reply). If 'return' is needed from
    elsewhere in function body, a 'yield' followed by 'raise
    StopIteration' would accomplish it.
    </li>
  <li>Within a coroutine, 'coro' variable refers to the coroutine
  (instance of Coro class). This variable can be used to invoke
  methods of Coro class, use it in other coroutines, for example, to
  wakeup from sleep etc. A coroutine has following methods:
    <ul>
      <li><b>suspend(timeout=None)</b> method should be used with
      'yield' statement. <b>sleep</b> method is synonym for
      suspend. If timeout is a positive number (float or int),
      AsynCoro suspends execution of coroutine until that many seconds
      (or fractions of second). If timeout is None, the coroutine is
      not woken up by AsynCoro - some other coroutine needs to resume
      it. The value yielded by this method is the value it is resumed
      with or None if resumed by AsynCoro due to timeout.  For
      example, if a coroutine executes <tt>v = yield
      coro.sleep(2.9)</tt>, it is suspended for 2.9 seconds. If before
      timeout, another coroutine wakes up this coroutine (with
      "resume" method) with a value, "v" is set to that
      value. Oterwise, after 2.9 seconds, this coroutine is resumed
      with "v" set to None.
      </li>
      <li>
	<b>resume(update=None)</b> method should be invoked on a
	suspended coroutine. <b>wakeup</b> method is synonym for
	resume. As explained above, the suspended coroutine gets
	"update" (any python object) as the value of yield statement
	that caused it to suspend. With suspend/resume methods,
	coroutines can synchronize their executions and possibly
	exchange data at specific execution points (compared to python
	generator functions that do so at every 'yield' statement,
	which can be very complex to program and understand for
	non-trivial programs).
	</li>
      <li>
	<b>throw(exc)</b> method throws exception exc to
	coroutine coro (at the point where it currently is executing).
	</li>
      <li>
	<b>terminate()</b> method terminates the coroutine. This
	is useful, for example, to terminate server processes that
	otherwise never terminate.
	</li>
      <li>
	<b>value()</b> method returns the last value yielded by
	the coroutine, possibly waiting until coroutine
	terminates. This method should not be called from a coroutine
	- this will cause entire coroutine framework to deadlock.
	This method is meant for main thread in the user program to
	wait for (main) coroutine(s) it creates.
	</li>
      </ul>
    </li>
  <li>
    A synchronous (normal) socket "sock" can be converted to
    asynchronous socket with <b>AsynCoroSocket</b>(sock). SSL can be
    enabled with <b>AsynCoroocket</b>(sock, keyfile=key,
    certfile=cert, ssl_version=version), where keyfile, certfile and
    ssl_version are as per wrap_socket method
    in <a href="http://docs.python.org/library/ssl.html">ssl
    module</a>. Socket operations accept, connect, send, recv, sendall,
    recvall, send_msg, recv_msg, sendto and recvfrom for asynchronous
    sockets must be used with 'yield' statement. The value of such
    yield statement is the result of the socket IO operation (for
    example, for recv, it would be the buffer received by the
    socket). The socket returned from accept method of an asynchronous
    socket is also an asynchronous socket, so there is no need to
    conver it. The methods recvall, send_msg and recv_msg are
    available for AsynCoroSocket only; they are not standard socket
    methods: recvall receives exactly given number of bytes
    (counterpart to sendall), send_msg prefixes the given buffer with
    the length so that receiving side knows exactly how many bytes to
    read, and recv_msg recieves full message from send_msg.
    </li>
  <li>
    <p>
      Database operations are blocking operations and do not provide
      asynchronous notification. asyncoro
      provides <b>AsynCoroDBCursor</b> that
      schedules <tt>execute</tt>, <tt>executemany</tt>
      and <tt>callproc</tt> operations through a thread pool (see
      below) for asynchronous completion. Other database operations
      are considered very fast. This interface works with MySQLdb
      under Python version 2.x
      and <a href="https://github.com/petehunt/PyMySQL">pymysql</a>
      under Python version 3.x. If necessary other database interfaces
      and operations can be made asynchronous with <b>AsynCoroThreadPool</b>.
    </p>
    <p>
      As database connections and cursors are not supposed to be
      shared among threads, asyncoro serializes operations on a
      cursor. Operations on different cursors at the same time are run
      concurrently. A simple example is

      <code># create pool of async cursors (can be reused)
num_threads = 3
thread_pool = asyncoro.AsynCoroThreadPool(num_threads)
async_cursors = []
for x in range(num_threads):
    conn = MySQLdb.connect(host=host, user=user, passwd=passwd, db=db)
    cursor = conn.cursor(cursorclass=MySQLdb.cursors.DictCursor)
    async_cursors.append(asyncoro.AsynCoroDBCursor(thread_pool, cursor))

coros = []
for x, cursor in itertools.izip(xrange(10), itertools.cycle(async_cursors)):
    coros.append(asyncoro.Coro(db_proc, cursor, stmt))

def db_proc(cursor, stmt, coro=None):
    # ...
    n = yield cursor.execute(stmt)
    rows = cursor.fetchall()
    # process rows</code>
      </p>
    </li>
  <li>
    <b>AsynCoroThreadPool</b> can be used to schedule synchronous,
    time consuming operations with a pool of threads for asynchronous
    completions (similar to sockets). A new thread pool can be created
    with <tt>AsynCoroThreadPool(num_threads)</tt>.  It provides three
    methods:
    <ul>
      <li><b>add_task</b>(coro, func, *args, **kwargs)
	schedules <tt>func</tt> with arguments <tt>args</tt> and keyword
	arguments <tt>kwargs</tt> with the thread pool. This method
	suspends the calling coroutine <tt>coro</tt>, so it must be used
	with 'yield'. Once the task is complete, <tt>coro</tt> is
	resumed with the return value from <tt>func</tt>. Thus,

	<code>thread_pool = AsynCoroThreadPool(3)
v = yield thread_pool.add_task(coro, f, 1)</code>
	executes function <tt>f(1)</tt> in a thread and its return
	value is set to <tt>v</tt>.
      </li>
      <li><b>join</b> method waits for all scheduled tasks to be
	completed. More tasks can be added if necessary.
      </li>
      <li><b>terminate</b> method waits for all scheduled tasks to be
	completed and terminates the threads. Tasks added later will
	not be executed.
      </li>
    </ul>
    </li>
  <li>
    asyncoro provides <b>Lock</b>, <b>Condition</b>, <b>Event</b>
    and <b>Semaphore</b> primitives. They are similar to versions in
    threading module. Any blocking operaitons on these primitives must
    be called with 'yield' appropriately. For example, acquiring a
    semaphore may block, so it should be invoked as <tt>yield
    sem.acquire()</tt>. Similarly, Event's wait method and Condition's
    wait method must be used as
    <tt>yield event.wait()</tt> or <tt>yield
    condition.wait()</tt>. For example, Condition variable cv in a
    client should be used as

    <code>while True:
      cv.acquire()
      while not an_item_is_available():
          yield cv.wait()
      get_an_available_item()
      yield cv.release()</code>

    'yield' is used when releasing a lock to be cooperative with other
    coroutines that might be waiting for their turn to
    execute. Technically, locking is not required, as there is no
    forced preemption with coroutines and at most one coroutine is
    executing at anytime. Currently the locking and unlocking
    opertions simply assert that 'yield' is not used between lock and
    corresponding unlock. If one wants to maintain same program for
    both synchronous and asynchronous models, it would be simple to
    interchange threading.Lock and asyncoro.Lock, threading.Condition
    and asyncoro.Condition etc., and a few syntactic changes. However,
    if there is no need to go back to synchronous model, it is very
    appealing to not worry about locking at all with asyncoro.
    </li>
  <li>
    Within a coroutine, generator functions (that are not coroutines)
    must be called with 'yield' statement. If 'g' is a generator
    function, it should be called with <tt>v = yield g()</tt>.
    </li>
  </ul>

<h4>Examples</h4>
<ul>
  <li>
    <a href="http://sourceforge.net/projects/dispy/files">dispy</a> is
    a framework for parallel execution of computations by distribyting
    them to multiple processors on a single node (SMP), nodes in a
    cluster, or large clusters. dispy is implemented with asyncoro, so the
    files in dispy may help understand asyncoro.
  </li>
  <li>
    Following is asyncoro version
    of <a href="http://nichol.as/asynchronous-servers-in-python">Ping Pong
      Benchmark</a> web server, for comparison of both the approach (ease of
    programming) and performance:
<code>import socket
from asyncoro import AsynCoroSocket, Coro, AsynCoro

def process(conn, coro=None):
    conn = AsynCoroSocket(conn)
    yield conn.sendall("HTTP/1.0 200 OK\r\nContent-Length: 5\r\n\r\nPong!\r\n")
    conn.close()

if __name__ == '__main__':
    scheduler = AsynCoro()

    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    sock.bind(('', 8010))
    sock.listen(5000)

    while True:
        try:
            conn, addr = sock.accept()
        except KeyboardInterrupt:
            break
        Coro(process, conn)
    scheduler.terminate()
</code>
  </li>
  </ul>

	  </div>
	</div> 
      </div> 
    </div> 
    <div id="footer"> 
      <p> 
        <a href="http://sourceforge.net/"> 
          Project Web Hosted by <img src="http://sflogo.sourceforge.net/sflogo.php?group_id=539226&amp;type=3" alt="SourceForge.net" /> 
        </a> 
      </p> 
      <p> 
        &copy;Copyright 1999-2009 -
        <a href="http://geek.net" title="Network which provides and promotes Open Source software downloads, development, discussion and news."> 
          Geeknet</a>, Inc., All Rights Reserved
      </p> 
      <p> 
        <a href="http://sourceforge.net/about"> 
          About
        </a> 
        -
        <a href="http://sourceforge.net/tos/tos.php"> 
          Legal
        </a> 
        -
        <a href="http://p.sf.net/sourceforge/getsupport"> 
          Help
        </a> 
      </p> 
    </div> 
  </body> 
</html> 
